<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>proposal</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="proposal_files/libs/clipboard/clipboard.min.js"></script>
<script src="proposal_files/libs/quarto-html/quarto.js"></script>
<script src="proposal_files/libs/quarto-html/popper.min.js"></script>
<script src="proposal_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="proposal_files/libs/quarto-html/anchor.min.js"></script>
<link href="proposal_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="proposal_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="proposal_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="proposal_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="proposal_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="proposal_files/libs/quarto-diagram/mermaid.min.js"></script>
<script src="proposal_files/libs/quarto-diagram/mermaid-init.js"></script>
<link href="proposal_files/libs/quarto-diagram/mermaid.css" rel="stylesheet">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="project-overview" class="level2">
<h2 class="anchored" data-anchor-id="project-overview">Project Overview</h2>
<section id="project-type" class="level3">
<h3 class="anchored" data-anchor-id="project-type">Project Type</h3>
<ul class="task-list">
<li><label><input type="checkbox" checked="">New package proposal</label></li>
<li><label><input type="checkbox">Implementation of suggested topic: [Topic name if applicable]</label></li>
</ul>
</section>
<section id="description" class="level3">
<h3 class="anchored" data-anchor-id="description">Description</h3>
<p>This package will be used to analyze electricity prices in New England by location (locational marginal prices, also known as LMPs). The package will pull from the ISO New England API to get the most recent data on electricity prices and provide functions to analyze and visualize this data. We will use spacial data to visualize the prices on a map of New England. We will also combine this with shapefiles of transmission lines in order to visualize transmission congestion, which is a major driver of electricity prices.</p>
</section>
<section id="dependencies" class="level3">
<h3 class="anchored" data-anchor-id="dependencies">Dependencies</h3>
<ol type="1">
<li>httr2
<ul>
<li>What it does: Tools for creating and modifying HTTP requests, then performing them and processing the results.</li>
<li>What functionality will you use: Perform HTTP requests for API data retrieval.</li>
</ul></li>
<li>jsonlite
<ul>
<li>What it does: Parser and generator for JSON.</li>
<li>What functionality will you use: Parsing JSON data from API responses.</li>
</ul></li>
<li>dplyr
<ul>
<li>What it does: Tool for working with data frame like objects for data manipulation.</li>
<li>What functionality will you use: Cleaning and pre-processing data for analysis and visualization.</li>
</ul></li>
<li>tidyr
<ul>
<li>What it does: Tools for creating tidy data.</li>
<li>What functionality will you use: Transforming data for analysis and visualization.</li>
</ul></li>
<li>ggplot2
<ul>
<li>What it does: ggplot2 is used for data visualization and mapping</li>
<li>What functionality will you use: We will use ggplot2 to create maps of New England with electricity prices and transmission congestion. We will also use it to create other visualizations of the data.</li>
</ul></li>
<li>sf
<ul>
<li>What it does: Standardized way to encode spatial vector data</li>
<li>What functionality will you use: Reading shapefiles for creating graphical visualizations</li>
</ul></li>
<li>leaflet
<ul>
<li>What it does: Create and customize interactive maps</li>
<li>What functionality will you use: Creating interactive maps for visualizing geographical data</li>
</ul></li>
<li>ggspacial
<ul>
<li>What it does: ggspacial is used for mapping spatial data</li>
<li>What functionality will you use: We may use ggspacial to aid in the creation of our maps and visualizations.</li>
</ul></li>
<li>maps
<ul>
<li>What it does: maps is used for providing basic map data</li>
<li>What functionality will you use: We may use maps to aid in the creation of our maps and visualizations for the mapping data inputs.</li>
</ul></li>
<li>tmap</li>
</ol>
<ul>
<li>What it does: tmap is used for creating thematic maps</li>
<li>What functionality will you use: We will use tmap to help make our maps easier to visualize and read</li>
</ul>
<ol start="11" type="1">
<li>rgdal</li>
</ol>
<ul>
<li>What it does: rgdal is used for reading and writing spatial data</li>
<li>What functionality will you use: We will use rgdal to help read in transmission shapefiles for our maps</li>
</ul>
</section>
<section id="similar-packages" class="level3">
<h3 class="anchored" data-anchor-id="similar-packages">Similar Packages</h3>
<p>Describe any similar existing packages and how your package differs or extends their functionality:</p>
<ol type="1">
<li>USgrid
<ul>
<li>Current capabilities: Provides a set of regular time-series datasets, describing the US electricity grid, including the total demand and supply as well as the demand by energy source (coal, solar, wind, etc.). Additionally, the package only provides data for U.S. mainland states (excluding Alaska and Hawaii).</li>
<li>How your package differs: Our package will focus on a specific region within the United States (New England) and will provide data on regarding the pricing of electricity rather than its demand. Additionally, we will be primarily visualizing data using maps rather than graphs.</li>
</ul></li>
<li>eia
<ul>
<li>Current capabilities: provides API access to data from the US Energy Information Administration (EIA). The datasets returned by these functions are provided in a tidy format. It also offers helper functions for working with EIA API date strings and time formats and for inspecting different summaries of data metadata.</li>
<li>How your package differs: Both our package and eia will provide access to an API, but we will be focusing on a different API and focus more on geographical data and visualizations. However, the eia provides a baseline for how we should use R to wrap the data from the API.</li>
</ul></li>
</ol>
</section>
</section>
<section id="project-planning" class="level2">
<h2 class="anchored" data-anchor-id="project-planning">Project Planning</h2>
<section id="team-member-responsibilities" class="level3">
<h3 class="anchored" data-anchor-id="team-member-responsibilities">Team Member Responsibilities</h3>
<section id="luke-mcfaul-lmcfaul" class="level4">
<h4 class="anchored" data-anchor-id="luke-mcfaul-lmcfaul">Luke McFaul (lmcfaul)</h4>
<p>Responsibilities:</p>
<ol type="1">
<li>Create ways to visualize LMP data and transmission congestion data on maps.</li>
<li>Build functions that allow for easier presentation of different electricity data cartographically.</li>
<li>Combining and visualizing data with optionality to allow users to explore and analyze New England grid data.</li>
</ol>
</section>
<section id="mack-smith-macks26" class="level4">
<h4 class="anchored" data-anchor-id="mack-smith-macks26">Mack Smith (macks26)</h4>
<p>Responsibilities:</p>
<ol type="1">
<li>Developing class for collecting and parsing data from API.</li>
<li>Cleaning, pre-processing, and transforming of data (once parsed) for analysis and visualizations.</li>
<li>Writing documentation and demo for using the developed API class.</li>
</ol>
</section>
<section id="kate-esbenshade-ksesben" class="level4">
<h4 class="anchored" data-anchor-id="kate-esbenshade-ksesben">Kate Esbenshade (ksesben)</h4>
<p>Responsibilities:</p>
<ol type="1">
<li>Data analysis: Creating functions that allow for easy data analysis, such as price comparisons between locations and time periods.</li>
<li>Data visualization: Creating functions that allow for easy visualization of the data, outside of the maps.</li>
</ol>
</section>
</section>
<section id="timeline" class="level3">
<h3 class="anchored" data-anchor-id="timeline">Timeline</h3>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">%%{init: {
  'gantt': {
    'axisFormat': '%-m/%-d',
    'tickInterval': '1week'
  }
}}%%
gantt
    title Project Timeline
    dateFormat  YYYY-MM-DD
    
    section Student 1 (lmcfaul)
    Transmission Data Collection   :a1, 2024-11-05, 7d
    Core Spacial Visualization      :a2, after a1, 10d
    Additional Visual add-ons          :a3, after a2, 7d
    Testing and Documentation       :a4, after a3, 7d
    
    section Kate Esbenshade (ksesben)
    Fake Data Generation:b1, 2024-11-06, 1d
    Data Analysis Functions :b2, after b1, 7d
    Data Visualization    :b3, after b2, 7d
    Testing with real data: b4, after b3, 3d
    Documentation       :b5, after b4, 5d
    
    section Student 3 (macks26)
    API Class Object    :c1, 2024-11-05, 10d
    Data Preparation    :c2, after c1, 10d
    Documentation       :c3, after c2, 4d
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
</section>
<section id="additional-considerations" class="level2">
<h2 class="anchored" data-anchor-id="additional-considerations">Additional Considerations</h2>
<section id="scope-and-limitations" class="level3">
<h3 class="anchored" data-anchor-id="scope-and-limitations">Scope and Limitations</h3>
<ul>
<li>This project will only be focusing on the states in the New England Independent System Operator (ISO), which is Connecticut, Maine, Massachusetts, New Hampshire, Rhode Island, and Vermont. The data is separate for each ISO, so to do a full analysis of the United States, we would need to expand the package to include data from other ISOs.</li>
<li>There will not be spacial data on generating stations, so we will only be estimating congestion through prices and transmission lines.</li>
</ul>
</section>
<section id="future-extensions" class="level3">
<h3 class="anchored" data-anchor-id="future-extensions">Future Extensions</h3>
<ul>
<li>Future expansions to this package could include more geographic areas of the U.S., or more ways to visualize the data. We are kind of imitating the website https://www.gridstatus.io/ but with more ways to visualize the data, so in theory this could use all of the data that grid status does.</li>
<li>Similarly, an expansion could add generating station data (if available) to the package to get a more complete picture of the electricity grid.</li>
<li>Lastly, an expansion could make modeling changes such as what the impacts of adding a new transmission line on prices would be, or methods of price prediction such as weather data.</li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "î§‹";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>